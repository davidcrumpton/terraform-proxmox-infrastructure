# SPDX-License-Identifier: MIT

workflow:
  rules:
    - changes:
      - "**/*.tf"
      - "**/*.tf.disabled"
      - ".gitlab-ci.yml"
      - "**/*.tpl"
      - "**/*.sh"
      - "**/*.yml"
      - "ansible/**"
    - when: never


variables:
  GIT_DEPTH: 0   # ensure full history, not shallow
  TF_ROOT: "${CI_PROJECT_DIR}"
  TF_PLUGIN_CACHE_DIR: "${CI_PROJECT_DIR}/.terraform-plugin-cache" # Cache plugins to speed up jobs
  TF_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/proxmox-homelab" # 'proxmox-homelab' is an arbitrary name for your state file/environment

# Shared cleanup steps
.before_cleanup: &before_cleanup
  - apk update && apk add --no-cache git
  - git clone --depth=1 $CI_REPOSITORY_URL repo-clean
  - cd repo-clean
  - git fetch --unshallow || true
  # Strip sensitive files before syncing
  - rm -rf .env terraform/ansible-vars/* *.tfvars

# Internal sync (Gitea)
sync_to_gitea:
  stage: sync_internal
  script:
    - *before_cleanup
    - git remote add gitea https://oauth2:${GITEA_TOKEN}@git.crumpton.org/bear/terraform-proxmox-infrastructure.git
    - git commit -am "Cleaned sync" || true
    - git push gitea main --force
    - git push gitea $CI_COMMIT_TAG
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\.\d+\.\d+\.\d+$/'

# External sync (GitHub) â€” manual approval required
sync_to_github:
  stage: sync_external
  script:
    - *before_cleanup
    - git remote add github https://oauth2:${GITHUB_TOKEN}@github.com/davidcrumpton/terraform-proxmox-infrastructure.git
    - git commit -am "Cleaned sync" || true
    - git push github main --force
    - git push github $CI_COMMIT_TAG
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\.\d+\.\d+\.\d+$/'
  when: manual   # requires manual approval in GitLab UI

stages:
  - validate
  - sync_internal
  - plan
  - apply
  - ansible
  - sync_external
  - destroy

image:
  name: "hashicorp/terraform:latest"
  entrypoint:
    - "/usr/bin/env"
    - "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

cache:
  paths:
    - "${TF_PLUGIN_CACHE_DIR}"
    - "${TF_ROOT}/.terraform"

before_script:
  - cd ${TF_ROOT}
  - mkdir -p "${TF_PLUGIN_CACHE_DIR}"
  - export PM_API_TOKEN_ID=$(echo $PM_API_TOKEN_ID | sed 's/\./!/g')
  - terraform --version
  - echo -n "${GITLAB_ACCESS_TOKEN}" | wc -c
  - export TF_STATE_NAME=proxmox-homelab
  - terraform init -backend-config="address=https://gitlab.crumpton.org/api/v4/projects/20/terraform/state/$TF_STATE_NAME" -backend-config="lock_address=https://gitlab.crumpton.org/api/v4/projects/20/terraform/state/$TF_STATE_NAME/lock" -backend-config="unlock_address=https://gitlab.crumpton.org/api/v4/projects/20/terraform/state/$TF_STATE_NAME/lock" -backend-config="username=bear" -backend-config="password=$GITLAB_ACCESS_TOKEN" -backend-config="lock_method=POST" -backend-config="unlock_method=DELETE" -backend-config="retry_wait_min=5" -reconfigure
validate:
  stage: validate
  script:
    - terraform validate
    - terraform fmt -check=true # Ensure consistent formatting
  only:
    - merge_requests

plan:
  stage: plan
  variables:
    TF_VAR_pm_api_url: "$PM_API_URL"
    TF_VAR_pm_user: "$PM_USER"
    TF_VAR_pm_api_token_id: "$PM_API_TOKEN_ID"
    TF_VAR_pm_api_token_secret: "$PM_API_TOKEN_SECRET"
  script:
  - terraform plan -out="${TF_ROOT}/tfplan.cache" 
  artifacts:
    expire_in: 1 day
    paths:
      - "${TF_ROOT}/tfplan.cache"
  only:
    - merge_requests
    - master
    - main

apply:
  stage: apply
  image: hashicorp/terraform:light
  script:
  - export ANSIBLE_VAULT_PASSWORD="${ANSIBLE_VAULT_PASSWORD}"
  - terraform apply -auto-approve "${TF_ROOT}/tfplan.cache"
  - terraform output -json > "${TF_ROOT}/tf_outputs.json" 
  dependencies:
    - plan
  artifacts:
    expire_in: 1 day
    paths:
      - "${TF_ROOT}/ansible/host_vars/*"
      - "${TF_ROOT}/tfplan.cache"
      - "${TF_ROOT}/ansible/inventory/hosts"
  when: manual # Requires manual approval in the GitLab UI
  only:
    - master
    - main

destroy:
  stage: destroy
  script:
    - terraform destroy -auto-approve
  when: manual # Requires manual approval, useful for tearing down lab environments
  only:
    - master
    - main

ansible_deploy:
  stage: ansible
  # image: "ansible/ansible-runner:latest"
  image: "demisto/ansible-runner:1.0.0.5807676"
  before_script: 
    - apk update && apk add --no-cache jq
    - echo -n "${SSH_PRIVATE_KEY_BASE_64}" | wc -c
    - mkdir -p ~/.ssh
    - echo -n "${SSH_PRIVATE_KEY_BASE_64}" | base64 -d > ~/.ssh/terraform
    - chmod 0600 ~/.ssh/terraform && chmod 700 ~/.ssh
    - ls -l ~/.ssh/terraform
  script:
    - export ANSIBLE_CONFIG=ansible/absible.cfg
    - export ANSIBLE_ROLES_PATH=ansible/playbook/roles
    - ansible --version
    - DB_PASS=$(jq -r '.wikijs_db_password.value' "${TF_ROOT}/tf_outputs.json")
    - ADMIN_PASS=$(jq -r '.wikijs_admin_password.value' "${TF_ROOT}/tf_outputs.json")
    - |
      printf "wikijs_db_password: %s\nwikijs_admin_password: %s\n" \
             "$DB_PASS" \
             "$ADMIN_PASS" | \
      ansible-vault encrypt /dev/stdin --output ansible/vault.yml --vault-id default@<(echo "$ANSIBLE_VAULT_PASSWORD")
    - ansible-playbook -i ansible/inventory/hosts ansible/playbooks/site.yml --private-key ~/.ssh/terraform -u root
  needs:
    - job: apply
      artifacts: true  # Waits for apply and downloads its artifacts
  dependencies:
    - apply
  when: on_success
  only:
    - main


license_check:
  stage: validate
  image: alpine:latest
  before_script: 
    - apk update && apk add --no-cache git
  script:
    - echo "Checking LICENSE file..."
    - test -f LICENSE

    - echo "Checking SPDX headers..."
    # File extensions to check
    - FILES=$(git ls-files '*.tf' '*.sh' '*.yml' '*.yaml' '*.md')
    - |
      NO_ERRORS=true
      for f in $FILES; do
        if ! grep -q "SPDX-License-Identifier: MIT" "$f"; then
          echo "---------------------> Missing SPDX header in: $f"
          NO_ERRORS=false
        fi
      done
      $NO_ERRORS

    - echo "All SPDX headers present."
  only:
    - main
    - merge_requests